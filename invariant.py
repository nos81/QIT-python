# -*- coding: utf-8 -*-
# Author: Ville Bergholm 2011
"""Invariants module."""

from __future__ import print_function, division

import numpy as np
from numpy import array, empty, zeros, ones, sqrt, sin, cos, dot, sort, trace, kron, pi, r_, c_, linspace, meshgrid, roll, concatenate, angle
from numpy.linalg import det, eigvals
from scipy.linalg import norm
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

from base import *



def canonical(U):
    """Canonical local invariants of a two-qubit gate.

    Returns a vector of three real canonical local invariants for the
    U(4) matrix U, normalized to the range [0,1].

    %! Childs et al., "Lower bounds on the complexity of simulating quantum gates", PRA 68, 052311 (2003).
    Ville Bergholm 2004-2010
    """
    sigma = kron(sy, sy)
    U_flip = dot(dot(sigma, U.transpose()), sigma)  # spin flipped U
    temp = dot(U, U_flip) / sqrt(complex(det(U)))

    Lambda = eigvals(temp) #[exp(i*2*phi_1), etc]
    # logarithm to the branch (-1/2, 3/2]
    Lambda = angle(Lambda) / pi # divide pi away
    for k in range(len(Lambda)):
        if Lambda[k] <= -0.5:
            Lambda[k] += 2
    S = Lambda / 2
    S = sort(S)[::-1]  # descending order

    n = int(round(sum(S)))  # sum(S) must be an integer
    # take away extra translations-by-pi
    S -= r_[ones(n), zeros(4-n)]
    # put the elements in the correct order
    S = roll(S, -n)

    M = [[1, 1, 0], [1, 0, 1], [0, 1, 1]] # scaled by factor 2
    c = dot(M, S[:3])
    # now 0.5 >= c[0] >= c[1] >= |c[2]|
    # and into the Berkeley chamber using a translation and two Weyl reflections
    if c[2] < 0:
        c[0] = 1 - c[0]
        c[2] = -c[2]
    return c


def makhlin(U):
    """Makhlin local invariants of a two-qubit gate.

    Returns a vector of the three real Makhlin invariants corresponding
    to the U(4) gate U.

    Alternatively, given a vector of canonical invariants
    normalized to [0, 1], returns the corresponding Makhlin invariants.

    #! Yu. Makhlin, "Nonlocal Properties of Two-Qubit Gates and Mixed States, and the Optimization of Quantum Computations", QIP 1, 243 (2002).
    #! J. Zhang et al., "Geometric theory of nonlocal two-qubit operations", PRA 67, 042313 (2003).
    Ville Bergholm 2004-2010
    """
    if U.shape[-1] == 3:
        c = U
        # array consisting of vectors of canonical invariants
        c *= pi
        g = empty(c.shape)
        
        g[...,0] = (cos(c[...,0]) * cos(c[...,1]) * cos(c[...,2])) ** 2 - (sin(c[...,0]) * sin(c[...,1]) * sin(c[...,2])) ** 2
        g[...,1] = 0.25 * sin(2 * c[...,0]) * sin(2 * c[...,1]) * sin(2 * c[...,2])
        g[...,2] = 4 * g[...,0] - cos(2 * c[...,0]) * cos(2 * c[...,1]) * cos(2*c[...,2])
    else:
        # U(4) gate matrix    
        V = dot(Q_Bell.conj().transpose(), dot(U, Q_Bell))
        M = dot(V.transpose(), V)

        t1 = trace(M) ** 2
        t2 = t1 / (16 * det(U))
        g = array([t2.real, t2.imag, ((t1 - trace(dot(M, M))) / (4 * det(U))).real])
    return g


def max_concurrence(U):
    """Maximum concurrence generated by a two-qubit gate.

    Returns the maximum concurrence generated by the two-qubit
    gate U, starting from a tensor state.

    Alternatively, U may be given in terms of a vector of three
    canonical local invariants.

    %! B. Kraus and J. I. Cirac, "Optimal creation of entanglement using a two-qubit gate", PRA 63, 062309 (2001).
    Ville Bergholm 2006-2010
    """
    if U.shape[-1] == 4:
        # gate into corresponding invariants
        c = canonical(U)
    else:
        c = U
    temp = roll(c, 1, axis = -1)
    return np.max(abs(sin(pi * concatenate((c - temp, c + temp), axis = -1))), axis = -1)


def plot_makhlin_2q(sdiv=31, tdiv=31):
    """Plots the set of two-qubit gates in the space of Makhlin invariants.

    Plots the set of two-qubit gates in the space of Makhlin
    invariants, returns the surface handle h.

    The input parameters are the s and t divisions of the mesh.

    Ville Bergholm 2006-2010
    """
    import matplotlib.cm as cm
    import matplotlib.colors as colors

    s = linspace(0, pi,   sdiv)
    t = linspace(0, pi/2, tdiv)

    # more efficient than meshgrid
    #g1 = kron(cos(s).^2, cos(t).^4) - kron(sin(s).^2, sin(t).^4)
    #g2 = 0.25*kron(sin(2*s), sin(2*t).^2)
    #g3 = 4*g1 - kron(cos(2*s), cos(2*t).^2)
    #S = kron(s, ones(size(t)))
    #T = kron(ones(size(s)), t)

    # canonical coordinate plane (s, t, t) gives the entire surface of the set of gate equivalence classes
    S, T = meshgrid(s, t)
    c = c_[S.ravel(), T.ravel(), T.ravel()]
    G = makhlin(c).reshape(sdiv, tdiv, 3)
    C = max_concurrence(c).reshape(sdiv, tdiv)

    fig = plt.gcf()
    ax = Axes3D(fig)
    #TODO ax = fig.add_subplot(111, projection='3d')

    # mesh, waterfall?
    polyc = ax.plot_surface(G[:,:,0], G[:,:,1], G[:,:,2], rstride = 1, cstride = 1, cmap = cm.jet, norm = colors.Normalize(vmin=0, vmax=1, clip=True), alpha = 0.6)
    polyc.set_array(C.ravel() ** 2)  # FIXME colors
    ax.axis('equal')
    #ax.axis([-1, 1, -0.5, 0.5, -3, 3])
    #ax.shading('interp')

    ax.set_xlabel('$g_1$')
    ax.set_ylabel('$g_2$')
    ax.set_zlabel('$g_3$')
    plt.title('Makhlin stingray')

    # labels
    ax.text(1.05, 0, 2.7, 'I')
    ax.text(-1.05, 0, -2.7, 'SWAP')
    ax.text(-0.1, 0, 1.2, 'CNOT')
    ax.text(0.1, 0, -1.2, 'DCNOT')
    ax.text(0.1, 0.26, 0, 'SWAP$^{1/2}$')
    ax.text(0, -0.26, 0, 'SWAP$^{-1/2}$')

    cb = fig.colorbar(polyc, ax = ax)
    plt.show()
    return ax


def plot_weyl_2q():
    """Plots the two-qubit Weyl chamber.

    Plots the Weyl chamber for the local invariants
    of 2q gates.

    Ville Bergholm 2005-2010
    """
    fig = plt.gcf()
    ax = Axes3D(fig)
    #TODO ax = fig.add_subplot(111, projection='3d')
    plt.hold(True)
    ax.plot_surface(array([[0, 0.5, 1], [0, 0.5, 1]]), array([[0, 0, 0], [0, 0.5, 0]]), array([[0, 0, 0], [0, 0.5, 0]]), alpha = 0.2)
    ax.plot_surface(array([[0, 0.5], [0, 0.5]]), array([[0, 0.5], [0, 0.5]]), array([[0, 0], [0, 0.5]]), alpha = 0.2)
    ax.plot_surface(array([[0.5, 1], [0.5, 1]]), array([[0.5, 0], [0.5, 0]]), array([[0, 0], [0.5, 0]]), alpha = 0.2)
    #axis([0 1 0 0.5 0 0.5])
    ax.axis('equal')
    ax.set_xlabel('$c_1/\\pi$')
    ax.set_ylabel('$c_2/\\pi$')
    ax.set_zlabel('$c_3/\\pi$')
    plt.title('Two-qubit Weyl chamber')

    ax.text(-0.05, -0.05, 0, 'I')
    ax.text(1.05, -0.05, 0, 'I')
    ax.text(0.45, 0.55, 0.55, 'SWAP')
    ax.text(0.45, -0.05, 0, 'CNOT')
    ax.text(0.45, 0.55, -0.05, 'DCNOT')
    ax.text(0.20, 0.25, 0, 'SWAP$^{1/2}$')
    ax.text(0.75, 0.25, 0, 'SWAP$^{-1/2}$')
    plt.hold(False)
    return ax



def test():
    """Test script for invariant methods."""
    from utils import assert_o, rand_U
    import gate

    U = rand_U(4) # random two-qubit gate
    L = kron(rand_U(2), rand_U(2)) # random local 2-qubit gate
    cnot = gate.controlled(sx).data
    swap = gate.swap(2,2).data

    # canonical invariants
    #assert_o(norm(canonical(L) -[0, 0, 0]), 0, tol) # only point in Berkeley chamber with translation degeneracy, (0,0,0) =^ (1,0,0)
    assert_o(norm(canonical(cnot) -[0.5, 0, 0]), 0, tol)
    assert_o(norm(canonical(swap) -[0.5, 0.5, 0.5]), 0, tol)

    # Makhlin invariants
    c = canonical(U)
    g1 = makhlin(c)
    g2 = makhlin(U)
    assert_o(norm(g1-g2), 0, tol)

    # maximum concurrence
    assert_o(max_concurrence(L), 0, tol)
    assert_o(max_concurrence(cnot), 1, tol)
